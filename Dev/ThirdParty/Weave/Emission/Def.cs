
/*
*  Warewolf - The Easy Service Bus
*  Copyright 2014 by Warewolf Ltd <alpha@warewolf.io>
*  Licensed under GNU Affero General Public License 3.0 or later. 
*  Some rights reserved.
*  Visit our website for more information <http://warewolf.io/>
*  AUTHORS <http://warewolf.io/authors.php> , CONTRIBUTORS <http://warewolf.io/contributors.php>
*  @license GNU Affero General Public License <http://www.gnu.org/licenses/agpl-3.0.html>
*/


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;
using System.Emission.Meta;
using System.Emission.Contributors;
using System.Emission.Emitters;

namespace System.Emission
{
    /// <summary>
    /// Represents a logical group of related identifiers in a hierarchy, provides a mechanism
    /// for name generation and child scope creation.
    /// </summary>
    public interface IDesignatingScope
    {
        /// <summary>
        /// Gets the designated name that was generated by <see cref="ParentScope"/>.
        /// </summary>
        string Name { get; }
        /// <summary>
        /// Gets the parent scope that contains this scope.
        /// </summary>
        IDesignatingScope ParentScope { get; }
        /// <summary>
        /// Generates a designation that is unique in the context of this scope, <paramref name="suggestedDesignation"/>
        /// will be used if it is available. Otherwise a designation will be generated that closely resembles
        /// <paramref name="suggestedDesignation"/>.
        /// </summary>
        /// <param name="suggestedDesignation">The designation that the generated designation should resemble or possibly
        /// equal if available.</param>
        /// <returns>A unique designation based on <paramref name="suggestedDesignation"/>.</returns>
        string GenerateDesignation(string suggestedDesignation);
        /// <summary>
        /// Generates a child scope that has a unique designation in the context of this scope, see <see cref="GenerateDesignation"/>
        /// for details on designation generation.
        /// </summary>
        /// <param name="suggestedDesignation">The designation that should be used as a suggestion in the generation of the 
        /// child scope.</param>
        /// <returns>A child scope with a unique designation based on <paramref name="suggestedDesignation"/>.</returns>
        IDesignatingScope GenerateChildScope(string suggestedDesignation);
    }

    internal delegate MethodEmitter OverrideMethodDelegate(string name, MethodAttributes attributes, MethodInfo methodToOverride);

    internal interface IEmissionProxyHook
    {
        void MethodsInspected();
        void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
        bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
    }

    internal interface IEmissionContributor
    {
        void CollectElements(IEmissionProxyHook hook, MetaType model);
        void Generate(ClassEmitter @class, EmissionProxyOptions options);
    }

    internal interface IILEmitter
    {
        void Emit(IEmissionMemberEmitter member, ILGenerator gen);
    }

    internal sealed class DesignatingScope : IDesignatingScope
    {
        private string _name;
        private IDesignatingScope _parentScope;
        private Dictionary<string, int> _suggestionHistory;

        public string Name { get { return _name; } }
        public IDesignatingScope ParentScope { get { return _parentScope; } }

        public DesignatingScope()
        {
            _suggestionHistory = new Dictionary<string, int>();
        }

        private DesignatingScope(string name, IDesignatingScope parentScope)
        {
            _name = name;
            _parentScope = parentScope;
            _suggestionHistory = new Dictionary<string, int>();
        }

        public string GenerateDesignation(string suggestedDesignation)
        {
            if (String.IsNullOrEmpty(suggestedDesignation)) throw new ArgumentException("Suggested designation cannot be a null or empty string.", "suggestedDesignation");
            int attempts;

            if (!_suggestionHistory.TryGetValue(suggestedDesignation, out attempts))
            {
                _suggestionHistory.Add(suggestedDesignation, 0);
                return suggestedDesignation;
            }

            _suggestionHistory[suggestedDesignation] = ++attempts;
            return suggestedDesignation + "_" + attempts.ToString();
        }

        public IDesignatingScope GenerateChildScope(string suggestedDesignation)
        {
            return new DesignatingScope(GenerateDesignation(suggestedDesignation), this);
        }
    }

    internal sealed class EmissionCacheKey
    {
        private readonly MemberInfo _target;
        private readonly Type[] _interfaces;
        private readonly EmissionProxyOptions _options;
        private readonly Type _type;

        public EmissionCacheKey(MemberInfo target, Type type, Type[] interfaces, EmissionProxyOptions options)
        {
            _target = target;
            _type = type;
            _interfaces = interfaces ?? Type.EmptyTypes;
            _options = options;
        }

        public EmissionCacheKey(Type target, Type[] interfaces, EmissionProxyOptions options)
            : this(target, null, interfaces, options)
        {
        }

        public override int GetHashCode()
        {
            int result = _target.GetHashCode();

            foreach (Type inter in _interfaces) result += 29 + inter.GetHashCode();
            if (_options != null) result = 29 * result + _options.GetHashCode();
            if (_type != null) result = 29 * result + _type.GetHashCode();

            return result;
        }

        public override bool Equals(object obj)
        {
            if (this == obj) return true;

            EmissionCacheKey cacheKey = obj as EmissionCacheKey;
            if (cacheKey == null) return false;

            if (!Equals(_type, cacheKey._type)) return false;
            if (!Equals(_target, cacheKey._target)) return false;
            if (_interfaces.Length != cacheKey._interfaces.Length) return false;

            for (int i = 0; i < _interfaces.Length; i++)
                if (!Equals(_interfaces[i], cacheKey._interfaces[i]))
                    return false;

            if (!Equals(_options, cacheKey._options)) return false;
            return true;
        }
    }

    internal sealed class EmissionProxyOptions
    {
        public static readonly EmissionProxyOptions Default = new EmissionProxyOptions();

        private IEmissionProxyHook _hook;
        private Type _ipBaseType;
        private List<CustomAttributeBuilder> _additionalAttributes;

        public IEmissionProxyHook Hook { get { return _hook; } set { _hook = value; } }
        public Type InterfaceProxyBaseType { get { return _ipBaseType; } set { _ipBaseType = value; } }
        public List<CustomAttributeBuilder> AdditionalAttributes { get { return _additionalAttributes; } }

        public EmissionProxyOptions(IEmissionProxyHook hook)
        {
            _ipBaseType = typeof(object);
            _hook = hook;
            _additionalAttributes = new List<CustomAttributeBuilder>();
        }

        public EmissionProxyOptions()
            : this(new EmissionProxyHook())
        {
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(this, obj)) return true;

            EmissionProxyOptions emissionProxyOptions = obj as EmissionProxyOptions;
            if (ReferenceEquals(emissionProxyOptions, null)) return false;
            if (!Equals(_hook, emissionProxyOptions._hook)) return false;
            if (!Equals(_ipBaseType, emissionProxyOptions._ipBaseType)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int result = _hook != null ? _hook.GetType().GetHashCode() : 0;
            result = 29 * result + 0;
            result = 29 * result + 0;
            result = 29 * result + (_ipBaseType != null ? _ipBaseType.GetHashCode() : 0);
            return result;
        }
    }

    internal class EmissionProxyHook : IEmissionProxyHook
    {
        protected static readonly Type[] _ignoredMemberSourceTypes = new Type[] { typeof(object), typeof(MarshalByRefObject), typeof(ContextBoundObject) };

        public virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo)
        {
            Type declaringType = methodInfo.DeclaringType;

            for (int i = 0; i < _ignoredMemberSourceTypes.Length; i++)
                if (_ignoredMemberSourceTypes[i].Equals(declaringType))
                    return false;

            return true;
        }

        public virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo)
        {
        }

        public virtual void MethodsInspected()
        {
        }

        public override bool Equals(object obj)
        {
            return obj != null && obj.GetType() == GetType();
        }

        public override int GetHashCode()
        {
            return GetType().GetHashCode();
        }
    }
}
