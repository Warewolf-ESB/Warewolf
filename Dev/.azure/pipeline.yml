# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
  batch: true

pool:
  name: Default

jobs:

- job: build
  displayName: 'Compile'

  steps:
  - task: PowerShell@2
    inputs:
      filePath: '$(Agent.BuildDirectory)/s/Compile.ps1'
      arguments: '-AcceptanceTesting -MSBuildPath "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe"'

  - script: "\"$(Agent.BuildDirectory)/s/dev/.run/Job Shortcuts/Bare Metal/Other Unit Tests.bat\""
    displayName: 'Run Tests'

  - task: PublishTestResults@2
    inputs:
      testRunner: VSTest
      testResultsFiles: '$(Agent.BuildDirectory)/s/bin/AcceptanceTesting/TestResults/*.trx'
      failTaskOnFailedTests: true
      testRunTitle: 'Unit Tests'
      
  - script: 'if not exist "$(Agent.BuildDirectory)/s/bin/AcceptanceTesting/TestResults/*.trx" exit 1'

  - task: DeleteFiles@1
    inputs:
      SourceFolder: '$(Agent.BuildDirectory)\\s\\bin\\AcceptanceTesting'
      Contents: 'TestResults'

  - script: |
      docker create --name=$(Build.SourceVersion) registry.gitlab.com/warewolf/vstest
      docker cp "$(Agent.BuildDirectory)\s\bin\AcceptanceTesting" $(Build.SourceVersion):C:\BuildUnderTest
      docker commit $(Build.SourceVersion) registry.gitlab.com/warewolf/vstest:$(Build.SourceVersion)
      docker push registry.gitlab.com/warewolf/vstest:$(Build.SourceVersion)
    displayName: 'Publish Build Image'
      
- job: Zip_Tool_Specs
  displayName: 'Zip Tool Specs'
  dependsOn: build

  steps:
  - powershell: |
      Out-File -LiteralPath "$(Agent.BuildDirectory)\TestResults\RunTestsEntrypoint.ps1" -InputObject "Set-Location .\BuildUnderTest`n`&`".\Job Shortcuts\TestRun.ps1`" -RetryCount 6 -Projects Warewolf.Tools.Specs -Category Zip" -Encoding default -Force
      docker run -i --rm --memory 4g -v "$(Agent.BuildDirectory)\TestResults:C:\BuildUnderTest\TestResults" registry.gitlab.com/warewolf/vstest:$(Build.SourceVersion) powershell -File C:\BuildUnderTest\TestResults\RunTestsEntrypoint.ps1
    displayName: 'Run Tests'

  - task: PublishTestResults@2
    inputs:
      testRunner: VSTest
      testResultsFiles: '$(Agent.BuildDirectory)\\TestResults\\*.trx'
      failTaskOnFailedTests: true
      testRunTitle: 'Zip Tool Specs'
      
  - script: 'if not exist "$(Agent.BuildDirectory)\\TestResults\\*.trx" exit 1'

- job: build_release
  displayName: 'Compile for Release'
  dependsOn: [Zip_Tool_Specs]

  steps:
  - checkout: self
    clean: true
    persistCredentials: true

  - script: "powershell -NoProfile -NoLogo -ExecutionPolicy Bypass -NoExit -File \"$(Agent.BuildDirectory)/s/Compile.ps1\" -AcceptanceTesting -AutoVersion -Config Release -Target Rebuild -ProjectSpecificOutputs"
    displayName: 'Compile in Release Config'
    workingDirectory: '$(Agent.BuildDirectory)/s'

  - powershell: |
      Write-Host Testing Warewolf assembly file versions...
      $HighestReadVersion = "0.0.0.0"
      $LastReadVersion = "0.0.0.0"
      foreach ($file in Get-ChildItem -recurse "$(Agent.BuildDirectory)\s\Dev") {
          if (($file.Name.EndsWith(".dll") -or ($file.Name.EndsWith(".exe") -and -Not $file.Name.EndsWith(".vshost.exe"))) -and ($file.Name.StartsWith("Dev2.") -or $file.Name.StartsWith("Warewolf.") -or $file.Name.StartsWith("WareWolf")) -and $file.Name -ne "Warewolf.Usage.dll") {
              # Get version.
              $ReadVersion = [system.diagnostics.fileversioninfo]::GetVersionInfo($file.FullName).FileVersion
      
              # Find highest version
              $SeperateVersionNumbers = $ReadVersion.split(".")
              $SeperateVersionNumbersHighest = $HighestReadVersion.split(".")
              if ([convert]::ToInt32($SeperateVersionNumbers[0], 10) -gt [convert]::ToInt32($SeperateVersionNumbersHighest[0], 10)`
              -or [convert]::ToInt32($SeperateVersionNumbers[1], 10) -gt [convert]::ToInt32($SeperateVersionNumbersHighest[1], 10)`
              -or [convert]::ToInt32($SeperateVersionNumbers[2], 10) -gt [convert]::ToInt32($SeperateVersionNumbersHighest[2], 10)`
              -or [convert]::ToInt32($SeperateVersionNumbers[3], 10) -gt [convert]::ToInt32($SeperateVersionNumbersHighest[3], 10)){
                  $HighestReadVersion = $ReadVersion
              }
      
              # Check for invalid.
              if ($ReadVersion.StartsWith("0.0.") -or ($LastReadVersion -ne $ReadVersion -and $LastReadVersion -ne "0.0.0.0")) {
                  $getFullPath = $file.FullName
                  Write-Host ERROR! Invalid version! $getFullPath $ReadVersion $LastReadVersion
                  throw "ERROR! `"$getFullPath $ReadVersion`" is either an invalid version or not equal to `"$LastReadVersion`". All Warewolf assembly versions in `"$TestsPath`" must conform and cannot start with 0.0. or end with .0"
              }
              $LastReadVersion = $ReadVersion
          }
      }
      Out-File -LiteralPath "$(Agent.BuildDirectory)\s\Dev\Dev2.Server\bin\Release\net48\win\FullVersionString" -InputObject $HighestReadVersion -Encoding default -Force
      Out-File -LiteralPath "$(Agent.BuildDirectory)\s\Dev\Dev2.Studio\bin\Release\net48\win\FullVersionString" -InputObject $HighestReadVersion -Encoding default -Force
      git -C "$(Build.SourcesDirectory)" tag $HighestReadVersion
      git -C "$(Build.SourcesDirectory)" push https://gitlab.com/warewolf/warewolf $HighestReadVersion
      Write-Host "##vso[build.updatebuildnumber]$(Build.BuildNumber) ($HighestReadVersion)"

  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Agent.BuildDirectory)\\s\\Dev\\Dev2.Server\\bin\\Release\\net48\\win'
      ArtifactName: 'Release Server'
      publishLocation: 'Container'
      StoreAsTar: false

  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Agent.BuildDirectory)\\s\\Dev\\Dev2.Studio\\bin\\Release\\net48\\win'
      ArtifactName: 'Release Studio'
      publishLocation: 'Container'
      StoreAsTar: false
