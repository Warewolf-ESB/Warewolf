{"version":3,"file":"cdk-observers.umd.min.js","sources":["../../src/cdk/observers/observe-content.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {\n  AfterContentInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  Input,\n  NgModule,\n  NgZone,\n  OnDestroy,\n  Output,\n} from '@angular/core';\nimport {Observable, Subject, Subscription} from 'rxjs';\nimport {debounceTime} from 'rxjs/operators';\n\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\n@Injectable({providedIn: 'root'})\nexport class MutationObserverFactory {\n  create(callback: MutationCallback): MutationObserver | null {\n    return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n  }\n}\n\n\n/** An injectable service that allows watching elements for changes to their content. */\n@Injectable({providedIn: 'root'})\nexport class ContentObserver implements OnDestroy {\n  /** Keeps track of the existing MutationObservers so they can be reused. */\n  private _observedElements = new Map<Element, {\n    observer: MutationObserver | null,\n    stream: Subject<MutationRecord[]>,\n    count: number\n  }>();\n\n  constructor(private _mutationObserverFactory: MutationObserverFactory) {}\n\n  ngOnDestroy() {\n    this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n  }\n\n  /**\n   * Observe content changes on an element.\n   * @param element The element to observe for content changes.\n   */\n  observe(element: Element): Observable<MutationRecord[]>;\n\n  /**\n   * Observe content changes on an element.\n   * @param element The element to observe for content changes.\n   */\n  observe(element: ElementRef<Element>): Observable<MutationRecord[]>;\n\n  observe(elementOrRef: Element | ElementRef<Element>): Observable<MutationRecord[]> {\n    const element = elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n\n    return Observable.create(observer => {\n      const stream = this._observeElement(element);\n      const subscription = stream.subscribe(observer);\n\n      return () => {\n        subscription.unsubscribe();\n        this._unobserveElement(element);\n      };\n    });\n  }\n\n  /**\n   * Observes the given element by using the existing MutationObserver if available, or creating a\n   * new one if not.\n   */\n  private _observeElement(element: Element): Subject<MutationRecord[]> {\n    if (!this._observedElements.has(element)) {\n      const stream = new Subject<MutationRecord[]>();\n      const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n      if (observer) {\n        observer.observe(element, {\n          characterData: true,\n          childList: true,\n          subtree: true\n        });\n      }\n      this._observedElements.set(element, {observer, stream, count: 1});\n    } else {\n      this._observedElements.get(element)!.count++;\n    }\n    return this._observedElements.get(element)!.stream;\n  }\n\n  /**\n   * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n   * observing this element.\n   */\n  private _unobserveElement(element: Element) {\n    if (this._observedElements.has(element)) {\n      this._observedElements.get(element)!.count--;\n      if (!this._observedElements.get(element)!.count) {\n        this._cleanupObserver(element);\n      }\n    }\n  }\n\n  /** Clean up the underlying MutationObserver for the specified element. */\n  private _cleanupObserver(element: Element) {\n    if (this._observedElements.has(element)) {\n      const {observer, stream} = this._observedElements.get(element)!;\n      if (observer) {\n        observer.disconnect();\n      }\n      stream.complete();\n      this._observedElements.delete(element);\n    }\n  }\n}\n\n\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\n@Directive({\n  selector: '[cdkObserveContent]',\n  exportAs: 'cdkObserveContent',\n})\nexport class CdkObserveContent implements AfterContentInit, OnDestroy {\n  /** Event emitted for each change in the element's content. */\n  @Output('cdkObserveContent') event = new EventEmitter<MutationRecord[]>();\n\n  /**\n   * Whether observing content is disabled. This option can be used\n   * to disconnect the underlying MutationObserver until it is needed.\n   */\n  @Input('cdkObserveContentDisabled')\n  get disabled() { return this._disabled; }\n  set disabled(value: any) {\n    this._disabled = coerceBooleanProperty(value);\n    if (this._disabled) {\n      this._unsubscribe();\n    } else {\n      this._subscribe();\n    }\n  }\n  private _disabled = false;\n\n  /** Debounce interval for emitting the changes. */\n  @Input()\n  get debounce(): number { return this._debounce; }\n  set debounce(value: number) {\n    this._debounce = coerceNumberProperty(value);\n    this._subscribe();\n  }\n  private _debounce: number;\n\n  private _currentSubscription: Subscription | null = null;\n\n  constructor(private _contentObserver: ContentObserver,\n              private _elementRef: ElementRef<HTMLElement>,\n              private _ngZone: NgZone) {}\n\n  ngAfterContentInit() {\n    if (!this._currentSubscription && !this.disabled) {\n      this._subscribe();\n    }\n  }\n\n  ngOnDestroy() {\n    this._unsubscribe();\n  }\n\n  private _subscribe() {\n    this._unsubscribe();\n    const stream = this._contentObserver.observe(this._elementRef);\n\n    // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\n    // Consider brining it back inside the zone next time we're making breaking changes.\n    // Bringing it back inside can cause things like infinite change detection loops and changed\n    // after checked errors if people's code isn't handling it properly.\n    this._ngZone.runOutsideAngular(() => {\n      this._currentSubscription =\n          (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\n    });\n  }\n\n  private _unsubscribe() {\n    if (this._currentSubscription) {\n      this._currentSubscription.unsubscribe();\n    }\n  }\n}\n\n\n@NgModule({\n  exports: [CdkObserveContent],\n  declarations: [CdkObserveContent],\n  providers: [MutationObserverFactory]\n})\nexport class ObserversModule {}\n"],"names":["MutationObserverFactory","prototype","create","callback","MutationObserver","type","Injectable","args","providedIn","ContentObserver","_mutationObserverFactory","this","_observedElements","Map","ngOnDestroy","_this","forEach","_","element","_cleanupObserver","observe","elementOrRef","ElementRef","nativeElement","Observable","observer","stream","_observeElement","subscription","subscribe","unsubscribe","_unobserveElement","has","get","count","stream_1","Subject","mutations","next","characterData","childList","subtree","set","_a","disconnect","complete","delete","CdkObserveContent","_contentObserver","_elementRef","_ngZone","event","EventEmitter","_disabled","_currentSubscription","Object","defineProperty","value","coerceBooleanProperty","_unsubscribe","_subscribe","_debounce","coerceNumberProperty","ngAfterContentInit","disabled","runOutsideAngular","debounce","pipe","debounceTime","Directive","selector","exportAs","NgZone","Output","Input","ObserversModule","NgModule","exports","declarations","providers"],"mappings":"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"}