using System;
using System.Collections.Generic;
using System.Text;
using System.Windows;
using System.Diagnostics;


#pragma warning disable 1574
using Infragistics.Services;
using Infragistics.Collections.Services;
using Infragistics;

namespace Infragistics.Controls.Schedules.Services





{
	#region ActivityBase Class

	/// <summary>
	/// Base class for activity classes, like <see cref="Appointment"/>, <see cref="Journal"/> or <see cref="Task"/>.
	/// </summary>
	/// <seealso cref="Appointment"/>
	/// <seealso cref="Journal"/>
	/// <seealso cref="Task"/>
	/// <seealso cref="XamScheduleDataManager.GetActivities"/>
	[DebuggerDisplay("Id={Id}, Range={Start}-{End}, OwningResourceId={OwningResourceId}, OwningCalendarId={OwningCalendarId}, Description={Description}, DataItem={DataItem}")]
	public abstract class ActivityBase : PropertyChangeNotifierExtended
	{
		#region Data Structures

		#region StorageProps Class

		internal static class StorageProps
		{
			internal const int Id = 0;
			internal const int OwningResourceId = 1;
			internal const int OwningCalendarId = 2;
			internal const int Start = 3;
			internal const int End = 4;
			internal const int StartTimeZoneId = 5;
			internal const int EndTimeZoneId = 6;
			internal const int IsTimeZoneNeutral = 7;
			internal const int Subject = 8;
			internal const int Description = 9;
			internal const int IsVisible = 10;
			internal const int IsLocked = 11;
			/// <summary>
			/// Applies to recurring activities, but not occurrences and variances of a 
			/// recurring activity.
			/// </summary>
			internal const int Recurrence = 12;
			internal const int RecurrenceVersion = 13;
			internal const int MaxOccurrenceDateTime = 14;
			/// <summary>
			/// Applies to occurrences and variances - indicates the root template id.
			/// </summary>
			internal const int RootActivityId = 15;
			internal const int RootActivity = 16;
			/// <summary>
			/// Applies to occurrences and variances - indicates the date-time value 
			/// as generated by the recurrence.
			/// </summary>
			internal const int OriginalOccurrenceStart = 17;
			internal const int OriginalOccurrenceEnd = 18;
			internal const int IsOccurrenceDeleted = 19;
			internal const int VariantProperties = 20;
			internal const int ReminderInterval = 21;
			internal const int ReminderEnabled = 22;
			internal const int Reminder = 23;
			// SSP 12/8/10 - NAS11.1 Activity Categories
			// 
			internal const int Categories = 24;
			internal const int LastModifiedTime = 25;
			internal const int Metadata = 26;
			//internal const int ResourceRights = 23;
			// The following properties are not stored in the data source.
			// 
			internal const int IsInitializing = 27;
			internal const int IsVariance = 28;
			internal const int CachedPrevRecurrence = 29;
			internal const int BeginEditData = 30;
			internal const int EditClone = 31;
			internal const int EditClonedFrom = 32;
			internal const int IsAddNew = 33;
			internal const int IsInEdit = 34;
			internal const int PendingOperation = 35;
			internal const int Error = 36;

			// MD 1/5/11 - NA 11.1 - Exchange Data Connector
			internal const int OriginalDescriptionFormat = 37;

			internal const int LAST_PROP = OriginalDescriptionFormat;

			internal const string Name_OwningResource = "OwningResource";
			internal const string Name_OwningCalendar = "OwningCalendar";
			internal const string Name_IsOccurrenceDeleted = "IsOccurrenceDeleted";
			internal const string Name_RecurrenceVersion = "RecurrenceVersion";

			internal abstract class Info : StoragePropsInfo, ITypedPropertyChangeListener<ActivityBase, int>
			{
				/// <summary>
				/// Change in the value of one or more of these properties will make an occurrence a variance.
				/// </summary>
				internal readonly IMap<int, bool> _varianceDataProps = MapsFactory.CreateMapHelper<int, bool>( );

				/// <summary>
				/// These properties are synchornized with the root activity.
				/// </summary>
				internal readonly IMap<int, bool> _rootSynchronizedVarianceDataProps = MapsFactory.CreateMapHelper<int, bool>( );

				/// <summary>
				/// These properties are not copied when an activity is copied in the UI (fro example via drag 
				/// and drop). Copying has to go through CreateNew, EndEdit calls however when the data from
				/// the original is copied, the following properties are not copied over.
				/// </summary>
				internal readonly IMap<int, bool> _uiCopyActivityExcptionProps = MapsFactory.CreateMapHelper<int, bool>( );

				/// <summary>
				/// This map's key is the prop key and value is the flag used in the VariantProperties value.
				/// </summary>
				internal readonly IMap<int, long> _variantPropertyFlags = MapsFactory.CreateMapHelper<int, long>( );

				/// <summary>
				/// Delegate used to get the storage instance from an activity.
				/// </summary>
				protected readonly Func<ActivityBase, IPropertyStorage<ActivityBase, int>> _sr = i => i.Storage;

				protected override void Initialize( IMap<int, StoragePropsInfo.PropInfo> map )
				{
					StoragePropsInfo.PropInfo[] infos = new StoragePropsInfo.PropInfo[]
					{
						new TypedPropInfo<ActivityBase, string>( Id, "Id", _sr, new object[] { AppointmentProperty.Id, JournalProperty.Id, TaskProperty.Id } ),
						new TypedPropInfo<ActivityBase, string>( OwningResourceId, "OwningResourceId", _sr, new object[] { AppointmentProperty.OwningResourceId, JournalProperty.OwningResourceId, TaskProperty.OwningResourceId } ),
                        new TypedPropInfo<ActivityBase, string>( OwningCalendarId, "OwningCalendarId", _sr, new object[] { AppointmentProperty.OwningCalendarId, JournalProperty.OwningCalendarId, TaskProperty.OwningCalendarId } ),
						new TypedPropInfo<ActivityBase, DateTime?>( Start, "Start", _sr, new object[] { AppointmentProperty.Start, JournalProperty.Start, TaskProperty.Start } ),
						new TypedPropInfo<ActivityBase, DateTime?>( End, "End", _sr, new object[] { AppointmentProperty.End, JournalProperty.End, TaskProperty.End } ),
						new TypedPropInfo<ActivityBase, string>( StartTimeZoneId, "StartTimeZoneId", _sr, new object[] { AppointmentProperty.StartTimeZoneId, JournalProperty.StartTimeZoneId, TaskProperty.StartTimeZoneId } ),
						new TypedPropInfo<ActivityBase, string>( EndTimeZoneId, "EndTimeZoneId", _sr, new object[] { AppointmentProperty.EndTimeZoneId, JournalProperty.EndTimeZoneId, TaskProperty.EndTimeZoneId } ),
						new TypedPropInfo<ActivityBase, bool>( IsTimeZoneNeutral, "IsTimeZoneNeutral", _sr, new object[] { AppointmentProperty.IsTimeZoneNeutral, JournalProperty.IsTimeZoneNeutral, TaskProperty.IsTimeZoneNeutral } ),
						new TypedPropInfo<ActivityBase, string>( Subject, "Subject", _sr, new object[] { AppointmentProperty.Subject, JournalProperty.Subject, TaskProperty.Subject } ),
						new TypedPropInfo<ActivityBase, string>( Description, "Description", _sr, new object[] { AppointmentProperty.Description, JournalProperty.Description, TaskProperty.Description } ),
						new TypedPropInfo<ActivityBase, bool?>( IsVisible, "IsVisible", _sr, new object[] { AppointmentProperty.IsVisible, JournalProperty.IsVisible, TaskProperty.IsVisible } ),
						new TypedPropInfo<ActivityBase, bool?>( IsLocked, "IsLocked", _sr, new object[] { AppointmentProperty.IsLocked, JournalProperty.IsLocked, TaskProperty.IsLocked } ),
						new TypedPropInfo<ActivityBase, RecurrenceBase>( Recurrence, "Recurrence", _sr, new object[] { AppointmentProperty.Recurrence, JournalProperty.Recurrence, TaskProperty.Recurrence }, copyMethod: CopyMethod.CopyClone, converter: DateRecurrenceParser.GetConverter( ) ),
						new TypedPropInfo<ActivityBase, int>( RecurrenceVersion, Name_RecurrenceVersion, _sr, new object[] { AppointmentProperty.RecurrenceVersion, JournalProperty.RecurrenceVersion, TaskProperty.RecurrenceVersion } ),
						new TypedPropInfo<ActivityBase, RecurrenceBase>( CachedPrevRecurrence, "CachedPrevRecurrence", _sr, copyMethod: CopyMethod.None ),
						new TypedPropInfo<ActivityBase, bool>( IsVariance, "IsVariance", _sr ),
						new TypedPropInfo<ActivityBase, DateTime?>( MaxOccurrenceDateTime, "MaxOccurrenceDateTime", _sr, new object[] { AppointmentProperty.MaxOccurrenceDateTime, JournalProperty.MaxOccurrenceDateTime, TaskProperty.MaxOccurrenceDateTime } ),
						new TypedPropInfo<ActivityBase, string>( RootActivityId, "RootActivityId", _sr, new object[] { AppointmentProperty.RootActivityId, JournalProperty.RootActivityId, TaskProperty.RootActivityId } ),
						new TypedPropInfo<ActivityBase, ActivityBase>( RootActivity, "RootActivity", _sr ),
						new TypedPropInfo<ActivityBase, DateTime?>( OriginalOccurrenceStart, "OriginalOccurrenceStart", _sr, new object[] { AppointmentProperty.OriginalOccurrenceStart, JournalProperty.OriginalOccurrenceStart, TaskProperty.OriginalOccurrenceStart } ),
						new TypedPropInfo<ActivityBase, DateTime?>( OriginalOccurrenceEnd, "OriginalOccurrenceEnd", _sr, new object[] { AppointmentProperty.OriginalOccurrenceEnd, JournalProperty.OriginalOccurrenceEnd, TaskProperty.OriginalOccurrenceEnd } ),
						new TypedPropInfo<ActivityBase, bool>( IsOccurrenceDeleted, "IsOccurrenceDeleted", _sr, new object[] { AppointmentProperty.IsOccurrenceDeleted, JournalProperty.IsOccurrenceDeleted, TaskProperty.IsOccurrenceDeleted } ),
						new TypedPropInfo<ActivityBase, long>( VariantProperties, "VariantProperties", _sr, new object[] { AppointmentProperty.VariantProperties, JournalProperty.VariantProperties, TaskProperty.VariantProperties} ),
						new TypedPropInfo<ActivityBase, TimeSpan>( ReminderInterval, "ReminderInterval", _sr, new object[] { AppointmentProperty.ReminderInterval, JournalProperty.ReminderInterval, TaskProperty.ReminderInterval }, converter: new ScheduleTimeSpanConverter( ) ),
						new TypedPropInfo<ActivityBase, bool>( ReminderEnabled, "ReminderEnabled", _sr, new object[] { AppointmentProperty.ReminderEnabled, JournalProperty.ReminderEnabled, TaskProperty.ReminderEnabled } ),
						new TypedPropInfo<ActivityBase, Reminder>( Reminder, "Reminder", _sr, new object[] { AppointmentProperty.Reminder, JournalProperty.Reminder, TaskProperty.Reminder }, converter: new XmlDeserializerConverter( typeof( Reminder ) ), copyMethod: CopyMethod.CopyClone ),
						// SSP 12/8/10 - NAS11.1 Activity Categories
						// 
						new TypedPropInfo<ActivityBase, string>( Categories, "Categories", _sr, new object[] { AppointmentProperty.Categories, JournalProperty.Categories, TaskProperty.Categories }, copyMethod: CopyMethod.CopyValue ),
						new TypedPropInfo<ActivityBase, DateTime?>( LastModifiedTime, "LastModifiedTime", _sr, new object[] { AppointmentProperty.LastModifiedTime, JournalProperty.LastModifiedTime, TaskProperty.LastModifiedTime } ),
						new TypedPropInfo<ActivityBase, MetadataPropertyValueStore>( Metadata, "Metadata", _sr, isReadOnly: true, copyMethod: CopyMethod.CopyContents, defaultValueFactoryFunc: CreateDefaultMetadata<ActivityBase>, equalityComparer: new DelegateEqualityComparer<MetadataPropertyValueStore>( MetadataPropertyValueStore.HasSameValues, MetadataPropertyValueStore.GetHashCode ) ),
						//new TypedPropInfo<ActivityBase, IDictionary<Resource, ResourceRights>>( ResourceRights, "ResourceRights", _sr, new object[] { AppointmentProperty.ResourceRights, JournalProperty.ResourceRights, TaskProperty.ResourceRights } ),
						new TypedPropInfo<ActivityBase, ActivityBase>( BeginEditData, "BeginEditData", _sr, copyMethod: CopyMethod.None ),
						new TypedPropInfo<ActivityBase, ActivityBase>( EditClone, "EditClone", _sr, copyMethod: CopyMethod.None ),
						new TypedPropInfo<ActivityBase, ActivityBase>( EditClonedFrom, "EditClonedFrom", _sr, copyMethod: CopyMethod.None ),
						new TypedPropInfo<ActivityBase, bool>( IsAddNew, "IsAddNew", _sr, copyMethod: CopyMethod.None ),
						new TypedPropInfo<ActivityBase, bool>( IsInEdit, "IsInEdit", _sr, copyMethod: CopyMethod.None ),
						new TypedPropInfo<ActivityBase, bool>( IsInitializing, "IsInitializing", _sr, copyMethod: CopyMethod.None ),
						new TypedPropInfo<ActivityBase, OperationResult>( PendingOperation, "PendingOperation", _sr, copyMethod: CopyMethod.None ),
						new TypedPropInfo<ActivityBase, DataErrorInfo>( Error, "Error", _sr, copyMethod: CopyMethod.None ),

						// MD 1/5/11 - NA 11.1 - Exchange Data Connector
						new TypedPropInfo<ActivityBase, DescriptionFormat>( OriginalDescriptionFormat, "OriginalDescriptionFormat", _sr, copyMethod: CopyMethod.CopyValue )
					};

					FillMap( infos, map );

					// Change in the value of one or more of these properties will make an occurrence a variance.
					// 
					int[] varianceDataProps = new int[]
					{
						OwningResourceId,
						OwningCalendarId,
						Start,
						End,
						StartTimeZoneId,
						EndTimeZoneId,
						IsTimeZoneNeutral,
						Subject,
						Description,
						IsVisible,
						IsLocked,
						IsOccurrenceDeleted,
						ReminderInterval,
						// Reminders for occurrences are managed using the root activity's Reminder's LastModifiedTime
						// value. As an occurrence's reminder is dismissed and as a result its ReminderEnabled is set to
						// false, we should not make it a variance.
						// 
						//ReminderEnabled,
						Reminder,
						Metadata
					};

					// These properties are synchornized with the root activity.
					// 
					int[] rootSynchronizedVarianceDataProps = new int[]
					{
						//NOTE: Any new members must be added to the end of this list. Don't insert items because
						// these are used to determine the variant property flags.
						// 
						OwningResourceId,
						OwningCalendarId,
						StartTimeZoneId,
						EndTimeZoneId,
						IsTimeZoneNeutral,
						Subject,
						Description,
						IsVisible,
						IsLocked,
						ReminderInterval,
						// Reminders for occurrences are managed using the root activity's Reminder's LastModifiedTime
						// value. When root's ReminderEnabled is set to true or false, we can't synchronize the property
						// to all occurrences because that would enable the reminders of past occurrences as well. In
						// this case, we should only enable the reminders of the future occurrences. Therefore the
						// ReminderEnabled needs to be managed manually.
						// 
						//ReminderEnabled,
						Reminder,
						Metadata,
						// SSP 12/8/10 - NAS11.1 Activity Categories
						// 
						Categories
					};

					// Setup variant property flags. Since these are serialized out, the values for a property must not change.
					// In other words, the above table must remain fixed and any new entries must be added to the end.
					// 
					for ( int i = 0; i < rootSynchronizedVarianceDataProps.Length; i++ )
					{
						_variantPropertyFlags[rootSynchronizedVarianceDataProps[i]] = 1L << i;
					}

					// These properties are not copied when an activity is copied in the UI (fro example via drag 
					// and drop). Copying has to go through CreateNew, EndEdit calls however when the data from
					// the original is copied, the following properties are not copied over.
					// 
					int[] uiCopyActivityExcptionProps = new int[]
					{
						Id,
						RootActivityId,
						RootActivity,
						IsVariance,
						IsLocked,
						OriginalOccurrenceStart,
						OriginalOccurrenceEnd,
						IsOccurrenceDeleted,
						MaxOccurrenceDateTime
					};

					int[] unmappedPropertiesStoreCandidates = new int[]
					{
						StartTimeZoneId,
						EndTimeZoneId,
						Subject,
						Description,
						IsVisible,
						IsLocked,
						VariantProperties,
						Reminder,
						LastModifiedTime,
						// SSP 12/8/10 - NAS11.1 Activity Categories
						// 
						Categories
					};

					MapsFactory.SetValues( _varianceDataProps, varianceDataProps, true );
					MapsFactory.SetValues( _rootSynchronizedVarianceDataProps, rootSynchronizedVarianceDataProps, true );
					MapsFactory.SetValues( _uiCopyActivityExcptionProps, uiCopyActivityExcptionProps, true );
					MapsFactory.SetValues( _unmappedPropertiesStoreCandidates, unmappedPropertiesStoreCandidates, true );
				}

				public void OnPropertyValueChanged( ActivityBase item, int property, object extraInfo )
				{
					PropInfo info = this.Props[property];

					Debug.Assert( null != info );

					if ( null != info )
					{
						
						switch ( property )	
						{
							case StorageProps.Recurrence:
								RecurrenceBase prevRecurrence = item.GetValueHelper<RecurrenceBase>( CachedPrevRecurrence );
								ScheduleUtilities.ManageListenerHelper( ref prevRecurrence, item.Recurrence, item, true );
								item.SetValueHelper<RecurrenceBase>( CachedPrevRecurrence, prevRecurrence );
								break;
								// Don't raise property change for these properties.
								// 
							case StorageProps.CachedPrevRecurrence:
								return;
						}

						// Don't raise notifications while we are initializing because the values should remain
						// the same after initialization process. Do however raise the IsInitializing since that
						// will be raised when it's set to false, it should be raised when it's set to true.
						// 
						if ( StorageProps.IsInitializing == property || ! item.IsInitializing )
							item.RaisePropertyChangedEvent( info._name );
					}
				}

				public abstract ActivityBase CreateNew( );

				
				
				internal IPropertyStorage<ActivityBase, int> CreateDefaultStorage( ActivityBase item )
				{
					return new DictionaryPropertyStorage<ActivityBase, int>( this, this.GetDefaultValueFactories( ) );
				}
			}
		}

		#endregion // StorageProps Class 

		#endregion // Data Structures

		#region Member Vars

		//internal WeakReference _self;
		private IScheduleDataConnector _connector;






		private object _dataItem;

		private Resource _resource;
		private ResourceCalendar _calendar;

		private IPropertyStorage<ActivityBase, int> _storage;

		#endregion // Member Vars

		#region Base Overrides

		#region OnPropertyChanged

		internal override void OnSubObjectPropertyChanged( object sender, string property, object extraInfo )
		{
			base.OnSubObjectPropertyChanged( sender, property, extraInfo );
			
			if ( this == sender )
			{
				bool isPropertyEmpty = string.IsNullOrEmpty( property );
				bool owningResourceIdChanged = false;

				switch ( property )
				{
					case "OwningResourceId":
						owningResourceIdChanged = true;
						break;
					case "OwningCalendarId":
						if ( null != _calendar && _calendar.Id != this.OwningCalendarId )
						{
							_calendar = null;
							this.RaisePropertyChangedEvent( StorageProps.Name_OwningCalendar );
						}
						break;
					case "IsVisible":
						this.RaisePropertyChangedEvent( "IsVisibleResolved" );
						break;
						// Raise Duration property change whenever Start and End changes.
						// 
					case "Start":
					case "End":
						this.RaisePropertyChangedEvent( "Duration" );
						break;
				}

				if ( isPropertyEmpty || owningResourceIdChanged && null != _resource && _resource.Id != this.OwningResourceId )
				{
					_resource = null;

					// When the owner changes, null out the calendar so we reget it in the calendar
					// property's getter.
					// 
					this.SyncOwner_NullOutCalendarHelper( );

					this.RaisePropertyChangedEvent( StorageProps.Name_OwningResource );
				}
			}
		}

		#endregion // OnPropertyChanged 

		#endregion // Base Overrides

		#region Properties

		#region Public Properties

		#region ActivityType

		/// <summary>
		/// Gets the ActivityType of this activity.
		/// </summary>
		public abstract ActivityType ActivityType
		{
			get;
		}

		#endregion // ActivityType

		#region Categories

		// SSP 12/8/10 - NAS11.1 Activity Categories
		// 
		/// <summary>
		/// Specifies categories associated with this activity as a comma separated list of category id's.
		/// </summary>



		public string Categories
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.Categories );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.Categories, value );
			}
		}

		#endregion // Categories

		#region DataItem

		/// <summary>
		/// Gets the underlying data item if any.
		/// </summary>
		public object DataItem
		{
			get
			{
				ViewItemManager<ActivityBase>.IdToken idToken = this.IdToken;

				if (idToken != null)
					return idToken.DataItem;

				return _dataItem;
			}
			set
			{
				_dataItem = value;
			}
		}

		#endregion // DataItem

		#region Description

		/// <summary>
		/// Gets or sets the text associated with this activity.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// While the <b>Subject</b> property is a short summary or title of the activity, the <b>Description</b> property 
		/// is the full text of the activity.
		/// </para>
		/// </remarks>
		/// <see cref="Subject"/>
		public string Description
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.Description );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.Description, value );
			}
		}

		#endregion // Description

		#region Duration

		/// <summary>
		/// Gets the duration of the activity.
		/// </summary>
		public TimeSpan Duration
		{
			get
			{
				return this.End - this.Start;
			}
		}

		#endregion // Duration

		#region End

		/// <summary>
		/// Specifies the time in <b>UTC</b> when the activity ends.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <see cref="Start"/> and <b>End</b> properties specify the time of the activity in <b>UTC</b>.
		/// You can use the <see cref="GetStartLocal"/> and <see cref="GetEndLocal"/> methods to get
		/// the time relative to a specific time-zone. Also there are <see cref="SetStartLocal"/> and
		/// <see cref="SetEndLocal"/> methods that can be used to specify activity times that are relative
		/// to a specific time-zone.
		/// </para>
		/// </remarks>
		/// <seealso cref="Start"/>
		/// <seealso cref="GetStartLocal"/>
		/// <seealso cref="GetEndLocal"/>
		/// <seealso cref="SetStartLocal"/>
		/// <seealso cref="SetEndLocal"/>
		public DateTime End
		{
			get
			{
				DateTime ret = this.GetValueHelper<DateTime?>( StorageProps.End ) ?? default( DateTime );
				return ScheduleUtilities.SpecifyKindUtc( ret );
			}
			set
			{
				this.SetValueHelper<DateTime?>( StorageProps.End, ScheduleUtilities.SpecifyKindUtc( value ) );
			}
		}

		#endregion // End

		#region EndTimeZoneId

		/// <summary>
		/// The time-zone id associated with the activity. The <see cref="Start"/> and <see cref="End"/> times are always in UTC.
		/// </summary>
		public string EndTimeZoneId
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.EndTimeZoneId );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.EndTimeZoneId, value );
			}
		}

		#endregion // EndTimeZoneId

		#region Error

		/// <summary>
		/// Gets or sets the error if any associated with the activity.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// When there's an activity specific error, for example an attempt to update an activity
		/// with invalid data results in an error, <b>Error</b> property will be set to a 
		/// <see cref="DataErrorInfo"/> object containing the error information.
		/// </para>
		/// <para class="body">
		/// You can set the <i>Error</i> to a new <i>DataErrorInfo</i> object or set it to 
		/// <i>null</i> to clear an existing error. The <i>Error</i> is cleared automatically by
		/// when the user performs another operation on the activity that succeeds.
		/// </para>
		/// <para class="body">
		/// <b>Note</b> that the <i>XamScheduleDataManager</i>'s <see cref="XamScheduleDataManager.Error"/>
		/// event is raised whenever there's an error, including activity errors. You can hook into
		/// that event if you want to get notified of when an error occurs.
		/// </para>
		/// </remarks>
		/// <seealso cref="DataErrorInfo"/>
		/// <seealso cref="XamScheduleDataManager.Error"/>
		// SSP 10/20/10 TFS57589
		// Added XmlIgnoreAttribute so the object can be serialized using XmlSerializer.
		// 
		[System.Xml.Serialization.XmlIgnoreAttribute]
		public DataErrorInfo Error
		{
			get
			{
				return this.GetValueHelper<DataErrorInfo>( StorageProps.Error );
			}
			set
			{
				this.SetValueHelper<DataErrorInfo>( StorageProps.Error, value );
			}
		}

		#endregion // Error

		#region Id

		/// <summary>
		/// Gets or sets the appointment Id.
		/// </summary>
		public string Id
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.Id );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.Id, value );
			}
		}

		#endregion // Id

		#region IsLocked

		/// <summary>
		/// Specifies whether the activity can be modified in the UI.
		/// </summary>
		public bool? IsLocked
		{
			get
			{
				return this.GetValueHelper<bool?>( StorageProps.IsLocked );
			}
			set
			{
				this.SetValueHelper<bool?>( StorageProps.IsLocked, value );
			}
		}

		#endregion // IsLocked

		#region IsOccurrence
		/// <summary>
		/// Returns true if the <see cref="ActivityBase"/> is an occurrence of a recurring <see cref="ActivityBase"/> (read only).
		/// </summary>
		/// <seealso cref="Recurrence"/>
		/// <seealso cref="RootActivity"/>
		/// <seealso cref="IsRecurrenceRoot"/>
		/// <seealso cref="IsVariance"/>
		public bool IsOccurrence
		{
			get { return this.RootActivity != null; }
		}
		#endregion //IsOccurrence

		#region IsOccurrenceDeleted

		/// <summary>
		/// Gets or sets a value indicating whether the occurrence has been deleted.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>Note</b> that simply setting this property to true will not delete the occurrence.
		/// Use the <see cref="XamScheduleDataManager.Remove"/> method to remove an occurrence.
		/// Also note that the underlying occurrence will be made into a variance which will
		/// be stored in the data source. This is so the the recurring activity knows not to
		/// generate the occurrence the next time the application is run.
		/// </para>
		/// <para class="body">
		/// <b>IsOccurrenceDeleted</b> property's setter is meant to be called by a schedule data
		/// connector implementation to specifiy that this occurrence has been deleted when the 
		/// activity is retrieved from the data source.
		/// </para>
		/// </remarks>
		public bool IsOccurrenceDeleted
		{
			get
			{
				return this.GetValueHelper<bool>( StorageProps.IsOccurrenceDeleted );
			}
			set
			{
				this.SetValueHelper<bool>( StorageProps.IsOccurrenceDeleted, value );
			}
		}

		#endregion // IsOccurrenceDeleted

		#region IsRecurrenceRoot
		/// <summary>
		/// Returns true if the <see cref="ActivityBase"/> is a recurring <see cref="ActivityBase"/> with a define set of <see cref="RecurrenceBase"/> rules (read only).
		/// </summary>
		/// <seealso cref="Recurrence"/>
		/// <seealso cref="RootActivity"/>
		/// <seealso cref="IsOccurrence"/>
		public bool IsRecurrenceRoot
		{
			get { return this.Recurrence != null; }
		}
		#endregion //IsRecurrenceRoot

		#region IsTimeZoneNeutral

		/// <summary>
		/// Specifies whether the activitiy's times are time-zone neutral or "floating".
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// Certain activities have start and end times that are time-zone neutral. Holidays are an example of that
		/// where a holiday starts at a certain time, let's say 12:00 AM, in every time-zone. Likewise you can have 
		/// activities that are time-zone neutral as well. Such activities start at the same numerical time value
		/// in any time-zone, and thus the actual UTC times when the activity starts will vary across time-zones.
		/// </para>
		/// <para class="body">
		/// When an activity is time-zone neutral, the values of <see cref="Start"/> and <see cref="End"/> properties
		/// are time-zone neutral times that are interpreted as local times.
		/// </para>
		/// </remarks>
		/// <seealso cref="ActivitySettings.AllowTimeZoneNeutral"/>
		public bool IsTimeZoneNeutral
		{
			get
			{
				return this.GetValueHelper<bool>( StorageProps.IsTimeZoneNeutral );
			}
			set
			{
				this.SetValueHelper<bool>( StorageProps.IsTimeZoneNeutral, value );
			}
		}

		#endregion // IsTimeZoneNeutral

		#region IsVariance

		/// <summary>
		/// Gets or sets a value indicating if the activity is a variance of an occurrence.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// When an occurrence of a recurring activity is modified, it becomes a 'variance'. Essentially it's
		/// a modified occurrence. Any modifications, including modifications to Start, End, Subject etc...
		/// cause the occurrence to be a variance.
		/// </para>
		/// <para class="body">
		/// <see cref="ListScheduleDataConnector"/> stores variances in the underlying data source list where
		/// recurring activities are stored. Note that to programatically modify an occurrence and make it into
		/// a variance and store it into the data source, you must call <see cref="XamScheduleDataManager.BeginEdit(ActivityBase, out DataErrorInfo)"/> 
		/// and <see cref="XamScheduleDataManager.EndEdit(ActivityBase, bool)"/> methods.
		/// </para>
		/// <para class="body">
		/// <b>Note</b> that <see cref="IsOccurrence"/> property will return true for variances as well.
		/// </para>
		/// </remarks>
		/// <seealso cref="IsOccurrence"/>
		// SSP 10/20/10 TFS57589
		// Added XmlIgnoreAttribute so the object can be serialized using XmlSerializer.
		// 
		[System.Xml.Serialization.XmlIgnoreAttribute]
		public bool IsVariance
		{
			get
			{
				return this.GetValueHelper<bool>( StorageProps.IsVariance );
			}
			set
			{
				this.SetValueHelper<bool>( StorageProps.IsVariance, value );
			}
		}

		#endregion // IsVariance

		#region IsVisible

		/// <summary>
		/// Gets or sets whether the activity is visible.
		/// </summary>
		public bool? IsVisible
		{
			get
			{
				return this.GetValueHelper<bool?>( StorageProps.IsVisible );
			}
			set
			{
				this.SetValueHelper<bool?>( StorageProps.IsVisible, value );
			}
		}

		#endregion // IsVisible

		#region IsVisibleResolved

		/// <summary>
		/// Gets the resolved value indicating whether the activity is visible.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>Note</b> that this property doesn't indicate whether the activity is presently visible in the UI.
		/// It indicates whether the activity will be displayed in the UI when the containing date range is displayed
		/// in a schedule control.
		/// </para>
		/// </remarks>
		/// <seealso cref="IsVisible"/>
		public bool IsVisibleResolved
		{
			get
			{
				return this.IsVisible ?? true;
			}
		}

		#endregion // IsVisibleResolved

		#region LastModifiedTime

		/// <summary>
		/// Gets or sets the time in UTC when the activity was last modified.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>LastModifiedTime</b> property indicates the last time the activity was modified.
		/// This property is updated when the activity changes are committed via 
		/// <see cref="XamScheduleDataManager.EndEdit(ActivityBase, bool)"/> method. The property's value is not 
		/// updated as you set other properties on the activity.
		/// </para>
		/// </remarks>
		public DateTime LastModifiedTime
		{
			get
			{

				return this.GetValueHelper<DateTime?>( StorageProps.LastModifiedTime ) ?? default( DateTime );
			}
			set
			{
				this.SetValueHelper<DateTime?>( StorageProps.LastModifiedTime, value );
			}
		}

		#endregion // LastModifiedTime

		#region MaxOccurrenceDateTime

		/// <summary>
		/// A date-time value that's equal or greater than the date-time of the last occurrence of 
		/// the recurring activity.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>MaxOccurrenceDateTime</b> field is used to optimize retrieval of recurring activities by
		/// excluding recurring activities whose date ranges as defined by the <i>Start</i> and 
		/// <i>MaxOccurrenceDateTime</i> field values do not intersect with the date range for which 
		/// activities are being retrieved.
		/// </para>
		/// <para class="body">
		/// In the absense of <b>MaxOccurrenceDateTime</b> value, recurring activities are assumed to
		/// potentially recur forever and thus subject to evaluation when retrieving activities for
		/// a date range.
		/// </para>
		/// </remarks>
		public DateTime? MaxOccurrenceDateTime
		{
			get
			{
				return this.GetValueHelper<DateTime?>( StorageProps.MaxOccurrenceDateTime );
			}
			set
			{
				this.SetValueHelper<DateTime?>( StorageProps.MaxOccurrenceDateTime, value );
			}
		}

		#endregion // MaxOccurrenceDateTime

		#region Metadata

		/// <summary>
		/// Returns a MetadataPropertyValueStore object that's used for storing and retrieving metadata information.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// You can use the <b>Metadata</b> to store and later retrieve information. The information is stored in
		/// properties of your data items as specified in the <see cref="MetadataPropertyMappingCollection"/>.
		/// For example, the metadata property mappings is specified using the <see cref="AppointmentPropertyMappingCollection"/>'s
		/// <see cref="PropertyMappingCollection&lt;TKey, TMapping&gt;.MetadataPropertyMappings"/>
		/// property. Each property defined in the mapping collection has a corresponding entry in the returned MetadataPropertyValueStore.
		/// It's indexer is used to retrieve or set the the property's value. Furthermore, you can use bindings to
		/// bind to a specific value in the returned object.
		/// </para>
		/// </remarks>
		/// <seealso cref="MetadataPropertyMappingCollection"/>
		/// <seealso cref="PropertyMappingCollection&lt;TKey, TMapping&gt;.MetadataPropertyMappings"/>
		public MetadataPropertyValueStore Metadata
		{
			get
			{
				return this.GetValueHelper<MetadataPropertyValueStore>( StorageProps.Metadata );
			}
		}

		#endregion // Metadata

		#region OriginalOccurrenceEnd

		/// <summary>
		/// Only applies to occurrences of a recurring activity. Specifies the original date-time as it was generated
		/// by the recurrence.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// On a non-variance occurrence, this property returns the same value as <see cref="Start"/> 
		/// property. On a variance of an occurrence, this property returns the original date-time as it was generated
		/// by the recurrence and the <see cref="Start"/> property returns the actual date-time of the activity.
		/// <b>Note:</b> On an activity that's not an occurrence of a recurring activity, this property returns null.
		/// </para>
		/// </remarks>
		public DateTime OriginalOccurrenceEnd
		{
			get
			{
				return this.GetValueHelper<DateTime?>( StorageProps.OriginalOccurrenceEnd ) ?? default( DateTime );
			}
			set
			{
				this.SetValueHelper<DateTime?>( StorageProps.OriginalOccurrenceEnd, value );
			}
		}

		#endregion // OriginalOccurrenceEnd

		#region OriginalOccurrenceStart

		/// <summary>
		/// Only applies to occurrences of a recurring activity. Specifies the original date-time as it was generated
		/// by the recurrence.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// On a non-variance occurrence, this property returns the same value as <see cref="Start"/> 
		/// property. On a variance of an occurrence, this property returns the original date-time as it was generated
		/// by the recurrence and the <see cref="Start"/> property returns the actual date-time of the activity.
		/// <b>Note:</b> On an activity that's not an occurrence of a recurring activity, this property returns null.
		/// </para>
		/// </remarks>
		public DateTime OriginalOccurrenceStart
		{
			get
			{
				return this.GetValueHelper<DateTime?>( StorageProps.OriginalOccurrenceStart ) ?? default( DateTime );
			}
			set
			{
				this.SetValueHelper<DateTime?>( StorageProps.OriginalOccurrenceStart, value );
			}
		}

		#endregion // OriginalOccurrenceStart

		#region OwningCalendar

		/// <summary>
		/// Gets or sets the calendar to which this activity belongs.
		/// </summary>
		// SSP 10/20/10 TFS57589
		// Added XmlIgnoreAttribute so the object can be serialized using XmlSerializer.
		// 
		[System.Xml.Serialization.XmlIgnoreAttribute]
		public ResourceCalendar OwningCalendar
		{
			get
			{
				if ( null == _calendar )
					this.SyncCalendarId( true );

				return _calendar;
			}
			set
			{
				if ( _calendar != value )
				{
					_calendar = value;

					this.SyncCalendarId( false );

					this.RaisePropertyChangedEvent( StorageProps.Name_OwningCalendar );
				}
			}
		}

		#endregion // OwningCalendar

		#region OwningCalendarId

		/// <summary>
		/// Gets or sets the id of the calendar to which this activity belongs.
		/// </summary>
		public string OwningCalendarId
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.OwningCalendarId );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.OwningCalendarId, value );
			}
		}

		#endregion // OwningCalendarId

		#region OwningResource

		/// <summary>
		/// Gets or sets the owning resource.
		/// </summary>
		// SSP 10/20/10 TFS57589
		// Added XmlIgnoreAttribute so the object can be serialized using XmlSerializer.
		// 
		[System.Xml.Serialization.XmlIgnoreAttribute]
		public Resource OwningResource
		{
			get
			{
				if ( null == _resource )
					this.SyncOwnerId( true );

				return _resource;
			}
			set
			{
				if ( _resource != value )
				{
					_resource = value;

					this.SyncOwnerId( false );

					this.RaisePropertyChangedEvent( StorageProps.Name_OwningResource );
				}
			}
		}

		#endregion // OwningResource

		#region OwningResourceId

		/// <summary>
		/// Gets or sets the owning resource id.
		/// </summary>
		public string OwningResourceId
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.OwningResourceId );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.OwningResourceId, value );
			}
		}

		#endregion // OwningResourceId

		#region Recurrence

		/// <summary>
		/// Specifies recurrence rules.
		/// </summary>
		/// <seealso cref="DateRecurrence"/>
		public RecurrenceBase Recurrence
		{
			get
			{
				return this.GetValueHelper<RecurrenceBase>( StorageProps.Recurrence );
			}
			set
			{
				this.SetValueHelper<RecurrenceBase>( StorageProps.Recurrence, value );
			}
		}

		#endregion // Recurrence

		#region RecurrenceVersion

		/// <summary>
		/// Specifies the recurrence version.
		/// </summary>
		/// <seealso cref="DateRecurrence"/>
		public int RecurrenceVersion
		{
			get
			{
				return this.GetValueHelper<int>( StorageProps.RecurrenceVersion );
			}
			set
			{
				this.SetValueHelper<int>( StorageProps.RecurrenceVersion, value );
			}
		}

		#endregion // RecurrenceVersion

		#region ReminderEnabled

		/// <summary>
		/// Specifies whether the activitiy's reminder is enabled. Default value is <b>false</b>.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// If the reminder is enabled, and when it's displayed, if the user acknowledges the 
		/// reminder, this property is set to <b>false</b>. This effectively prevents the reminder 
		/// from being displayed again.
		/// </para>
		/// </remarks>
		/// <seealso cref="ReminderInterval"/>
		public bool ReminderEnabled
		{
			get
			{
				return this.GetValueHelper<bool>( StorageProps.ReminderEnabled );
			}
			set
			{
				this.SetValueHelper<bool>( StorageProps.ReminderEnabled, value );
			}
		}

		#endregion // ReminderEnabled

		#region ReminderInterval

		/// <summary>
		/// Specifies the reminder interval.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>Note</b> that you need to set the <see cref="ReminderEnabled"/> to <b>true</b> to enable the reminder.
		/// </para>
		/// </remarks>
		/// <seealso cref="ReminderEnabled"/>
		/// <seealso cref="Reminder"/>
		public TimeSpan ReminderInterval
		{
			get
			{
				return this.GetValueHelper<TimeSpan>( StorageProps.ReminderInterval );
			}
			set
			{
				this.SetValueHelper<TimeSpan>( StorageProps.ReminderInterval, value );
			}
		}

		#endregion // ReminderInterval

		#region Reminder

		/// <summary>
		/// Specifies the reminder information. Default value is null.
		/// </summary>
		/// <remarks>
		/// <b>Reminder</b> property is used to specify reminder information. If it's not specified
		/// then the property returns null, in which case default reminder text will be used in the
		/// reminder dialog.
		/// </remarks>
		/// <seealso cref="ReminderInterval"/>
		public Reminder Reminder
		{
			get
			{
				return this.GetValueHelper<Reminder>( StorageProps.Reminder );
			}
			set
			{
				this.SetValueHelper<Reminder>( StorageProps.Reminder, value );
			}
		}

		#endregion // Reminder

		#region ResourceRights

		///// <summary>
		///// Gets a dictionary that has rights override information for each resource. 
		///// </summary>
		///// <remarks>
		///// <para class="body">
		///// <b>Note:</b> By default this will be serialized as text as ';' separated pairs of 
		///// "resource_id: rights_flags" where rights_flags are comma separated ResourceRights 
		///// enum flags.
		///// </para>
		///// </remarks>
		///// <seealso cref="Infragistics.Controls.Schedules.ResourceRights"/>
		//public IDictionary<Resource, ResourceRights> ResourceRights
		//{
		//    get
		//    {
		//        return _resourceRights;
		//    }
		//    set
		//    {
		//        if ( _resourceRights != value )
		//        {
		//            _resourceRights = value;
		//        }
		//    }
		//}

		#endregion // ResourceRights

		#region RootActivity

		/// <summary>
		/// Gets the root activity. Only valid if this activity is an occurrence or a variance of a recurring activity.
		/// </summary>
		/// <seealso cref="RootActivity"/>
		// SSP 10/20/10 TFS57589
		// Added XmlIgnoreAttribute so the object can be serialized using XmlSerializer.
		// 
		[System.Xml.Serialization.XmlIgnoreAttribute]
		public ActivityBase RootActivity
		{
			get
			{
				return this.GetValueHelper<ActivityBase>( StorageProps.RootActivity );
			}
			set
			{
				this.SetValueHelper<ActivityBase>( StorageProps.RootActivity, value );
			}
		}

		#endregion // RootActivity

		#region RootActivityId

		/// <summary>
		/// If this activity is an occurrence or a variance of a recurring activity, gets the id of the recurring activity.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>RootActivityId</b> property returns the id of the root recurring activity. This property is only applicable
		/// to occurrence or a variance of a recurring activity. It returns null for other activities.
		/// </para>
		/// </remarks>
		/// <seealso cref="RootActivity"/>
		public string RootActivityId
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.RootActivityId );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.RootActivityId, value );
			}
		}

		#endregion // RootActivityId

		#region Start

		/// <summary>
		/// Specifies the time in <b>UTC</b> when the activity starts.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>Start</b> and <see cref="End"/> properties specify the time of the activity in <b>UTC</b>.
		/// You can use the <see cref="GetStartLocal"/> and <see cref="GetEndLocal"/> methods to get
		/// the time relative to a specific time-zone. Also there are <see cref="SetStartLocal"/> and
		/// <see cref="SetEndLocal"/> methods that can be used to specify activity times that are relative
		/// to a specific time-zone.
		/// </para>
		/// </remarks>
		/// <seealso cref="End"/>
		/// <seealso cref="GetStartLocal"/>
		/// <seealso cref="GetEndLocal"/>
		/// <seealso cref="SetStartLocal"/>
		/// <seealso cref="SetEndLocal"/>
		public DateTime Start
		{
			get
			{
                DateTime ret = this.GetValueHelper<DateTime?>( StorageProps.Start ) ?? default( DateTime );
				return ScheduleUtilities.SpecifyKindUtc( ret );
            }
            set
            {
                this.SetValueHelper<DateTime?>( StorageProps.Start, ScheduleUtilities.SpecifyKindUtc( value ) );
            }
        }

		#endregion // Start

		#region StartTimeZoneId

		/// <summary>
		/// The time-zone id associated with the activity. The <see cref="Start"/> and <see cref="End"/> field values are 
		/// always in UTC.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// <b>Note</b> that <see cref="Start"/> and <see cref="End"/> field values are always in UTC. <i>StartTimeZoneId</i>
		/// and <i>EndTimeZoneId</i> values simply give the activity the context of the time-zone to the activity.
		/// </para>
		/// </remarks>
		public string StartTimeZoneId
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.StartTimeZoneId );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.StartTimeZoneId, value );
			}
		}

		#endregion // StartTimeZoneId

		#region Subject

		/// <summary>
		/// Gets or sets the subject associated with this activity.
		/// </summary>
		/// <remarks>
		/// <para class="body">
		/// The <b>Subject</b> property specifies a short summary or title of the activity. The <see cref="Description"/> 
		/// property specifies the full text of the activity.
		/// </para>
		/// </remarks>
		/// <see cref="Description"/>
		public string Subject
		{
			get
			{
				return this.GetValueHelper<string>( StorageProps.Subject );
			}
			set
			{
				this.SetValueHelper<string>( StorageProps.Subject, value );
			}
		}

		#endregion // Subject

		#region VariantProperties

		/// <summary>
		/// Properties of a variance that have been modified and thus will not be synchronized with the root activity.
		/// </summary>
		public long VariantProperties
		{
			get
			{
				return this.GetValueHelper<long>( StorageProps.VariantProperties );
			}
			set
			{
				this.SetValueHelper<long>( StorageProps.VariantProperties, value );
			}
		}

		#endregion // VariantProperties

		#endregion // Public Properties

		#region Internal Properties

		#region BeginEditData

		/// <summary>
		/// Returns the data that was stored when BeginEdit was called.
		/// </summary>
		internal ActivityBase BeginEditData
		{
			get
			{
				return this.GetValueHelper<ActivityBase>( StorageProps.BeginEditData );
			}
		} 

		#endregion // BeginEditData

		#region EditClone

		private ActivityBase EditClone
		{
			get
			{
				return this.GetValueHelper<ActivityBase>( StorageProps.EditClone );
			}
		}

		#endregion // EditClone

		#region EditClonedFrom

		private ActivityBase EditClonedFrom
		{
			get
			{
				return this.GetValueHelper<ActivityBase>( StorageProps.EditClonedFrom );
			}
		} 

		#endregion // EditClonedFrom

		#region IdToken

		internal ViewItemManager<ActivityBase>.IdToken IdToken
		{
			get
			{
				return _dataItem as ViewItemManager<ActivityBase>.IdToken;
			}
			set
			{
				if (_dataItem != value)
				{
					_dataItem = value;

					
					
					
				}
			}
		}

		#endregion // IdToken 

		#region IsAddNew

		internal bool IsAddNew
		{
			get
			{
				return this.GetValueHelper<bool>( StorageProps.IsAddNew );
			}
			set
			{
				this.SetValueHelper<bool>( StorageProps.IsAddNew, value );
			}
		} 

		#endregion // IsAddNew

		#region IsEditCopy

		/// <summary>
		/// Returns true if this is a clone of an activity for edit purposes.
		/// </summary>
		internal bool IsEditCopy
		{
			get
			{
				return null != this.EditClonedFrom;
			}
		} 

		#endregion // IsEditCopy

		#region IsInEdit

		internal bool IsInEdit
		{
			get
			{
				return this.GetValueHelper<bool>( StorageProps.IsInEdit );
			}
			set
			{
				this.SetValueHelper<bool>( StorageProps.IsInEdit, value );
			}
		}

		#endregion // IsInEdit

		#region IsInitializing

		/// <summary>
		/// Returns true if this is activity is being initialized via <see cref="Initialize"/> call.
		/// </summary>
		internal bool IsInitializing
		{
			get
			{
				return this.GetValueHelper<bool>( StorageProps.IsInitializing );
			}
			private set
			{
				this.SetValueHelper<bool>( StorageProps.IsInitializing, value );
			}
		}

		#endregion // IsInitializing

		// MD 1/5/11 - NA 11.1 - Exchange Data Connector
		#region OriginalDescriptionFormat

		internal DescriptionFormat OriginalDescriptionFormat
		{
			get
			{
				return this.GetValueHelper<DescriptionFormat>(StorageProps.OriginalDescriptionFormat);
			}
			set
			{
				this.SetValueHelper<DescriptionFormat>(StorageProps.OriginalDescriptionFormat, value);
			}
		} 

		#endregion  // OriginalDescriptionFormat

		// MD 1/5/11 - NA 11.1 - Exchange Data Connector
		#region OriginalDescriptionFormatResolved

		internal DescriptionFormat OriginalDescriptionFormatResolved
		{
			get
			{
				DescriptionFormat originalDescriptionFormat = this.OriginalDescriptionFormat;

				if (originalDescriptionFormat != DescriptionFormat.Default)
					return originalDescriptionFormat;

				return DescriptionFormat.Text;
			}
		} 

		#endregion  // OriginalDescriptionFormatResolved

		#region PendingOperation

		/// <summary>
		/// Returns any pending operation on the activity.
		/// </summary>
		internal OperationResult PendingOperation
		{
			get
			{
				return this.GetValueHelper<OperationResult>( StorageProps.PendingOperation );
			}
			set
			{
				this.SetValueHelper<OperationResult>( StorageProps.PendingOperation, value );
			}
		}

		#endregion // PendingOperation

		#region PropsInfo

		internal abstract StorageProps.Info PropsInfo
		{
			get;
		}

		#endregion // PropsInfo

		#region Storage

		internal IPropertyStorage<ActivityBase, int> Storage
		{
			get
			{
				if ( null == _storage )
					
					
					
					
					_storage = this.PropsInfo.CreateDefaultStorage( this );

				return _storage;
			}
		}

		#endregion // Storage

		#endregion // Internal Properties

		#endregion // Properties

		#region Methods

		#region Public Methods

		#region GetEndLocal
		/// <summary>
		/// Returns the <see cref="End"/> relative to the specified <see cref="TimeZoneToken"/>
		/// </summary>
		/// <param name="token">The timezone token that identifies the timezone for which the relative date is being requested.</param>
		/// <returns>Returns the local time for the <see cref="End"/> relative to the timezone specified by the <paramref name="token"/>.</returns>
		/// <seealso cref="ScheduleDataConnectorBase.TimeZoneInfoProvider"/>
		/// <seealso cref="TimeZoneInfoProvider.GetTimeZoneToken(string)"/>
		/// <see cref="End"/>
		public DateTime GetEndLocal(TimeZoneToken token)
		{
			return GetLocal(token, false);
		}
		#endregion // GetEndLocal

		#region GetStartLocal
		/// <summary>
		/// Returns the <see cref="Start"/> relative to the specified <see cref="TimeZoneToken"/>
		/// </summary>
		/// <param name="token">The timezone token that identifies the timezone for which the relative date is being requested.</param>
		/// <returns>Returns the local time for the <see cref="Start"/> relative to the timezone specified by the <paramref name="token"/>.</returns>
		/// <seealso cref="ScheduleDataConnectorBase.TimeZoneInfoProvider"/>
		/// <seealso cref="TimeZoneInfoProvider.GetTimeZoneToken(string)"/>
		/// <see cref="Start"/>
		public DateTime GetStartLocal(TimeZoneToken token)
		{
			return GetLocal(token, true);
		}
		#endregion //GetStartLocal

		#region SetEndLocal
		/// <summary>
		/// Returns the <see cref="End"/> relative to the specified <see cref="TimeZoneToken"/>
		/// </summary>
		/// <param name="token">The timezone token that identifies the timezone for which the relative date is being requested.</param>
		/// <param name="dateTime">The time relative to the timezone specified by the <paramref name="token"/> that will be used to calculate the UTC value for the <see cref="End"/></param>
		/// <returns>Returns the local time for the <see cref="End"/> relative to the timezone specified by the <paramref name="token"/>.</returns>
		/// <seealso cref="ScheduleDataConnectorBase.TimeZoneInfoProvider"/>
		/// <seealso cref="TimeZoneInfoProvider.GetTimeZoneToken(string)"/>
		/// <see cref="End"/>
		public void SetEndLocal(TimeZoneToken token, DateTime dateTime)
		{
			SetLocal(token, false, dateTime);
		}
		#endregion // SetEndLocal

		#region SetStartLocal
		/// <summary>
		/// Returns the <see cref="Start"/> relative to the specified <see cref="TimeZoneToken"/>
		/// </summary>
		/// <param name="token">The timezone token that identifies the timezone for which the relative date is being requested.</param>
		/// <param name="dateTime">The time relative to the timezone specified by the <paramref name="token"/> that will be used to calculate the UTC value for the <see cref="Start"/></param>
		/// <returns>Returns the local time for the <see cref="Start"/> relative to the timezone specified by the <paramref name="token"/>.</returns>
		/// <seealso cref="ScheduleDataConnectorBase.TimeZoneInfoProvider"/>
		/// <seealso cref="TimeZoneInfoProvider.GetTimeZoneToken(string)"/>
		/// <see cref="Start"/>
		public void SetStartLocal(TimeZoneToken token, DateTime dateTime)
		{
			SetLocal(token, true, dateTime);
		}
		#endregion // SetStartLocal

		#endregion // Public Methods

		#region Internal Methods

		#region ApplyEditCopy

		internal bool ApplyEditCopy( bool clearEditCopy )
		{
			ActivityBase clone = this.EditClone;
			if ( null != clone )
			{
				if ( clearEditCopy )
					this.ClearEditCopy( );

				this.PropsInfo.CopyValues( clone, clone.Storage, this, this.Storage );
				return true;
			}

			return false;
		}

		#endregion // ApplyEditCopy

		#region BumpRecurrenceSequenceIfNecessary

		internal void BumpRecurrenceSequenceIfNecessary( )
		{
			Debug.Assert( this.IsRecurrenceRoot, "This method is appropriate for only the root activities." );
			if ( this.IsRecurrenceRoot && ! this.IsAddNew )
			{
				int[] recurrenceSequenceProps = new int[]
				{
					StorageProps.Recurrence,
					StorageProps.Start,
					StorageProps.End,
					StorageProps.StartTimeZoneId,
					StorageProps.EndTimeZoneId
				};

				var propsToCheck = MapsFactory.CreateMapHelper<int, bool>( );
				MapsFactory.SetValues( propsToCheck, recurrenceSequenceProps, true );

				if ( this.IsDataDifferentFromBeginEditDataHelper( propsToCheck, null ) )
				{
					int sequence = this.GetValueHelper<int>( StorageProps.RecurrenceVersion );
					this.SetValueHelper<int>( StorageProps.RecurrenceVersion, 1 + sequence );
				}
			}
		}

		#endregion // BumpRecurrenceSequenceIfNecessary

		#region ClearBeginEditData

		internal void ClearBeginEditData( )
		{
			this.ClearValueHelper<ActivityBase>( StorageProps.BeginEditData );
		} 

		#endregion // ClearBeginEditData

		#region ClearEditCopy

		internal void ClearEditCopy( )
		{
			ActivityBase cloneActivity = this.EditClone;
			if ( null != cloneActivity )
			{
				this.PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler( this.OnClonedFromPropertyChanged );

				this.ClearValueHelper<ActivityBase>( ActivityBase.StorageProps.EditClone );
				cloneActivity.ClearValueHelper<ActivityBase>( ActivityBase.StorageProps.EditClonedFrom );
			}
		}

		#endregion // ClearEditCopy

		#region ClearValueHelper

		internal void ClearValueHelper<T>( int property )
		{
			this.Storage.SetValue<T>( this, property, default( T ) );
		}

		#endregion // ClearValueHelper

		#region GetEditCopy

		/// <summary>
		/// Gets the clone of this activity for an editing purposes.
		/// </summary>
		/// <param name="allocateIfNecessary"></param>
		/// <param name="synchronizeChangesFromOriginalActivity"></param>
		/// <returns></returns>
		internal ActivityBase GetEditCopy( bool allocateIfNecessary, bool synchronizeChangesFromOriginalActivity )
		{
			ActivityBase clone = this.EditClone;
			if ( null == clone && allocateIfNecessary )
			{
				clone = this.Clone( true );
				this.SetValueHelper( StorageProps.EditClone, clone );
				clone.SetValueHelper( StorageProps.EditClonedFrom, this );

				clone.IsInEdit = this.IsInEdit;
				clone.IsAddNew = this.IsAddNew;				

				
				
				if ( synchronizeChangesFromOriginalActivity )
					this.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler( OnClonedFromPropertyChanged );
			}

			return clone;
		}

		private void OnClonedFromPropertyChanged( object sender, System.ComponentModel.PropertyChangedEventArgs e )
		{
			ActivityBase clonedFrom = this;
			ActivityBase clone = this.EditClone;

			Debug.Assert( null != clone, "When clone and cloned from are cleared we should have unhooked." );
			if ( null != clone )
			{
				StoragePropsInfo.PropInfo propInfo = this.PropsInfo.GetPropInfoFromName( e.PropertyName );
				if ( null != propInfo && StoragePropsInfo.CopyMethod.None != propInfo._copyMethod )
				{
					object newVal = clonedFrom.GetValueHelper<object>( propInfo._key );
					clone.SetValueHelper( propInfo._key, newVal );
				}
			}
		}

		#endregion // GetEditCopy

		#region GetEndUtc

		/// <summary>
		/// Returns the <see cref="End"/> in UTC.
		/// </summary>
		/// <param name="token">Identifies the local time zone.</param>
		/// <returns>Returns the UTC time for the <see cref="End"/>.</returns>
		/// <seealso cref="ScheduleDataConnectorBase.TimeZoneInfoProvider"/>
		/// <seealso cref="TimeZoneInfoProvider.GetTimeZoneToken(string)"/>
		/// <see cref="End"/>
		internal DateTime GetEndUtc( TimeZoneToken token )
		{
			return ScheduleUtilities.GetActivityEndUTC( this, token );
		}

		#endregion // GetEndUtc

		#region GetStartUtc

		/// <summary>
		/// Returns the <see cref="Start"/> in UTC.
		/// </summary>
		/// <param name="token">Identifies the local time zone.</param>
		/// <returns>Returns the UTC time for the <see cref="Start"/>.</returns>
		/// <seealso cref="ScheduleDataConnectorBase.TimeZoneInfoProvider"/>
		/// <seealso cref="TimeZoneInfoProvider.GetTimeZoneToken(string)"/>
		/// <see cref="End"/>
		internal DateTime GetStartUtc( TimeZoneToken token )
		{
			return ScheduleUtilities.GetActivityStartUTC( this, token );
		}

		#endregion // GetStartUtc

		#region GetValueHelper

		internal T GetValueHelper<T>( int property )
		{
			return this.Storage.GetValue<T>( this, property );
		}

		#endregion // GetValueHelper

		#region HasVariantDataFromBeginEditData

		/// <summary>
		/// Returns true if the the data of this activity is different from begin edit data for properties that are
		/// subject to making an occurrence a variance.
		/// </summary>
		/// <returns>True if any property's value is different from the original value when BeginEdit was called, for
		/// all properties that are taken into account when determining whether an activity should be made a variance
		/// of an occurrence.</returns>
		internal bool HasVariantDataFromBeginEditData( )
		{
			return this.IsDataDifferentFromBeginEditDataHelper( this.PropsInfo._varianceDataProps, null );
		}

		#endregion // HasVariantDataFromBeginEditData

		#region InitializeVariantPropertiesFlags

		internal long InitializeVariantPropertiesFlags( bool onlyIfZero = false )
		{
			long flags = this.VariantProperties;
			if ( !onlyIfZero || 0L == flags )
			{
				ActivityBase rootActivity = this.RootActivity;

				Debug.Assert( this.IsOccurrence, "This method is useful only on an occurrence." );
				Debug.Assert( null != rootActivity );

				if ( null != rootActivity )
				{
					IMap<int, bool> propsWithDifferentValues = MapsFactory.CreateMapHelper<int, bool>( );
					this.PropsInfo.IsDataDifferent( this, this.Storage, rootActivity, rootActivity.Storage, this.PropsInfo._varianceDataProps, propsWithDifferentValues );

					foreach ( int prop in propsWithDifferentValues )
						flags |= this.PropsInfo._variantPropertyFlags[prop];

					this.VariantProperties = flags;
				}
			}

			return flags;
		}

		#endregion // InitializeVariantPropertiesFlags

		#region IsDataDifferentFromBeginEditData

		/// <summary>
		/// Returns true if the the data of this activity is different from begin edit data.
		/// </summary>
		/// <param name="skipStateProps">If true skip state related properties like Error, PendingOperation etc... and only compare actual data properties.</param>
		/// <returns>True if data is different. False otherwise.</returns>
		internal bool IsDataDifferentFromBeginEditData( bool skipStateProps = true )
		{
			var filter = skipStateProps ? ii => StoragePropsInfo.CopyMethod.None != ii._copyMethod : (Predicate<StoragePropsInfo.PropInfo>)null;
			return this.IsDataDifferentFromBeginEditDataHelper( null, filter );
		}
		
		private bool IsDataDifferentFromBeginEditDataHelper( IMap<int, bool> propsList, Predicate<StoragePropsInfo.PropInfo> propsFilter )
		{
			Debug.Assert( ! ( null != propsList && null != propsFilter ), "Only one parameter can be specified at a time." );

			ActivityBase beginEditCopy = this.BeginEditData;
			if ( null != beginEditCopy )
			{
				if ( null != propsList )
					return this.PropsInfo.IsDataDifferent( this, this.Storage, beginEditCopy, beginEditCopy.Storage, propsList );
				else
					return this.PropsInfo.IsDataDifferent( this, this.Storage, beginEditCopy, beginEditCopy.Storage, propsFilter );
			}

			Debug.Assert( false, "This activity is not in edit mode." );
			return false;
		}

		#endregion // IsDataDifferentFromBeginEditData

		#region Initialize

		internal void Initialize(IScheduleDataConnector connector, IPropertyStorage<ActivityBase, int> storage = null)
		{
			_connector = connector;

			if (storage == null)
				return;

			if ( null == _storage )
			{
				_storage = storage;
			}
			else
			{
				bool origIsInitializing = this.IsInitializing;
				Debug.Assert( !origIsInitializing );
				this.IsInitializing = true;
				try
				{
					this.PropsInfo.InitializeNewStore( this, ref _storage, storage );
				}
				finally
				{
					this.IsInitializing = origIsInitializing;
				}
			}
		}

		#endregion // Initialize

		#region InitializeRootActivity

		/// <summary>
		/// Initializes the root activity of an occurrence instance.
		/// </summary>
		/// <param name="rootActivity">Root recurring activity.</param>
		/// <param name="occurrenceStart">Original date-time of the occurrence.</param>
		/// <remarks>
		/// <para class="body">
		/// <b>InitializeRootActivity</b> method is called by the data connector to initialize
		/// the <see cref="RootActivity"/> reference on an occurrence of a recurring activity.
		/// This method also sets the <see cref="RootActivityId"/> to the <see cref="ActivityBase.Id"/>
		/// of the specified root activity. It also sets the <see cref="OriginalOccurrenceStart"/>
		/// property to the specified 'occurrenceStart' value. <b>Note</b> that 
		/// </para>
		/// </remarks>
		/// <seealso cref="RootActivity"/>
		public void InitializeRootActivity( ActivityBase rootActivity, DateTime occurrenceStart )
		{
			this.RootActivity = rootActivity;
			this.RootActivityId = null != rootActivity ? rootActivity.Id : null;
			this.OriginalOccurrenceStart = occurrenceStart;
		}

		#endregion // InitializeRootActivity

		#region IsVariantPropertyFlagSet

		internal bool IsVariantPropertyFlagSet( int prop, bool initializeIfZero = false )
		{
			long flags = this.VariantProperties;
			if ( initializeIfZero && 0L == flags )
				flags = this.InitializeVariantPropertiesFlags( );

			return 0 != ( flags & this.PropsInfo._variantPropertyFlags[prop] );
		}

		#endregion // IsVariantPropertyFlagSet

		#region RaisePropertyChangedEvent

		internal new void RaisePropertyChangedEvent( string propName )
		{
			base.RaisePropertyChangedEvent( propName );
		}

		#endregion // RaisePropertyChangedEvent

		#region RestoreBeginEditData

		internal bool RestoreBeginEditData( )
		{
			ActivityBase origData = this.BeginEditData;
			if ( null == origData )
				return false;

			this.PropsInfo.CopyValues( origData, origData.Storage, this, this.Storage );
			this.ClearBeginEditData( );

			return true;
		} 

		#endregion // RestoreBeginEditData

		#region SetIsVariantProperty

		internal void SetIsVariantProperty( int prop, bool newValue )
		{
			long flags = this.VariantProperties;

			long propFlag = this.PropsInfo._variantPropertyFlags[prop];

			if ( newValue )
				flags |= propFlag;
			else
				flags &= ~propFlag;

			this.VariantProperties = flags;
		}

		#endregion // SetIsVariantProperty

		#region SetValueHelper

		internal void SetValueHelper<T>( int property, T newVal )
		{
			this.Storage.SetValue<T>( this, property, newVal );
		}

		#endregion // SetValueHelper

		#region StoreBeginEditData

		internal bool StoreBeginEditData( )
		{
			ActivityBase data = this.BeginEditData;
			if ( null != data )
				return false;

			data = this.Clone( true );
			this.SetValueHelper( StorageProps.BeginEditData, data );
			return true;
		} 

		#endregion // StoreBeginEditData

		#region UpdateLastModifiedTime

		/// <summary>
		/// Sets the <see cref="LastModifiedTime"/> to current time in UTC.
		/// </summary>
		internal void UpdateLastModifiedTime( )
		{
			this.LastModifiedTime = DateTime.UtcNow;
		} 

		#endregion // UpdateLastModifiedTime

		#endregion // Internal Methods

		#region Private Methods

		#region Clone

		internal ActivityBase Clone(bool copyId)
		{
			ActivityBase clone = this.PropsInfo.CreateNew( );			
			this.CopyToHelper( clone, copyId, false, false );

			return clone;
		}

		#endregion // Clone

		#region CopyToHelper

		/// <summary>
		/// Copies activity data from this activity to the specified 'dest' activity.
		/// </summary>
		/// <param name="dest">Destination activity to which to copy data.</param>
		/// <param name="copyId">Specifies whether to copy the id.</param>
		/// <param name="retainNonEmptyValuesInDest">True to keep non-empty values in the 'dest'. False to
		/// overwrite them with the values from the source.</param>
		/// <param name="makingCopyThroughUI">Specifiy true to indicate that the activity's data is being copied to a new activity
		/// that will be committed to the backend. For example, when the user copys an existing activity to make a new activity.
		/// This will except certain properties from being copied, like Id, RootActivityId among others.
		/// Specifiy false to indicate that the copying is being done for the purposes of storing activity data for
		/// later reference.</param>
		internal void CopyToHelper( ActivityBase dest, bool copyId, bool retainNonEmptyValuesInDest, bool makingCopyThroughUI )
		{
			Debug.Assert( !copyId || !makingCopyThroughUI, "When the user makes a copy of an activity, the Id should not be copied and should be left null so the backend fills it in." );

			StoragePropsInfo.MergeMethod mergeMethod = retainNonEmptyValuesInDest
				? StoragePropsInfo.MergeMethod.CopyNonEmptyValuesOnlyIfDestIsEmpty
				: StoragePropsInfo.MergeMethod.CopyAll;

			this.PropsInfo.Merge( this, this.Storage, dest, dest.Storage, mergeMethod,
				skipProperties: makingCopyThroughUI ? this.PropsInfo._uiCopyActivityExcptionProps : null );

			if ( copyId )
				dest._dataItem = _dataItem;
			else
				dest.Id = null;

			dest._connector = _connector;
			dest._resource = this.OwningResource;
			dest._calendar = this.OwningCalendar;
		}

		#endregion // CopyToHelper

		#region GetLocal
		private DateTime GetLocal(TimeZoneToken token, bool isStart)
		{
			//CoreUtilities.ValidateNotNull(token, "token");

			DateTime date = isStart ? this.Start : this.End;

			return this.GetLocalHelper( token, date );
		}

		internal DateTime GetLocalHelper( TimeZoneToken token, DateTime date )
		{
			if (token == null || this.IsTimeZoneNeutral)
				return DateTime.SpecifyKind(date, DateTimeKind.Unspecified);
			else
				return token.ConvertFromUtc(date);
		}
		#endregion // GetLocal

		#region SyncCalendarId

		private void SyncCalendarId( bool? syncWithId )
		{
			ResourceCalendar calendar = _calendar;
			string id = this.OwningCalendarId;

			if ( !syncWithId.HasValue )
				syncWithId = !string.IsNullOrEmpty( id );

			if ( syncWithId.Value )
			{
				Resource owner = this.OwningResource;
				this.OwningCalendar = null != owner ? owner.GetCalendar( id ) : null;
			}
			else
			{
				string newId = null != calendar ? calendar.Id : null;
				if ( id != newId )
					this.OwningCalendarId = newId;

				if ( null != calendar )
					this.OwningResource = calendar.OwningResource;
			}
		}

		#endregion // SyncCalendarId

		#region SyncOwner_NullOutCalendarHelper

		private bool SyncOwner_NullOutCalendarHelper( bool raisePropChanged = true )
		{
			Resource resource = _resource;
			if ( null != _calendar && ( null == resource || _calendar.OwningResource != resource ) )
			{
				_calendar = null;

				if ( raisePropChanged )
					this.RaisePropertyChangedEvent( StorageProps.Name_OwningCalendar );

				return true;
			}

			return false;
		}

		#endregion // SyncOwner_NullOutCalendarHelper

		#region SyncOwnerId

		private void SyncOwnerId( bool? syncWithId )
		{
			Resource owner = _resource;
			string id = this.OwningResourceId;

			if ( !syncWithId.HasValue )
				syncWithId = !string.IsNullOrEmpty( id );

			// If id changed then set the owner based on the new id.
			// 
			if ( syncWithId.Value )
			{
				ResourceCollection resources = null != _connector ? _connector.ResourceItems : null;

				Resource oldOwner = _resource;
				_resource = null != resources ? resources.GetResourceFromId( id ) : null;

				// If the owner changes, make sure the OwningCalendar is updated to reflect the new owner's calendar.
				// 
				if ( oldOwner != _resource )
					this.SyncOwner_NullOutCalendarHelper( );
			}
				// Otherwise if the owner changed then set the id based on the new owner as well
				// as update the calendar accordingly.
				// 
			else
			{
				// When the owner changes, reset the calendar to a matching calendar in the new
				// owner's calendars collection. If new owner is null or has no matching calendar
				// then null out the calendar.
				// 
				bool raiseCalendar = this.SyncOwner_NullOutCalendarHelper( false );

				this.OwningResourceId = null != owner ? owner.Id : null;

				if ( raiseCalendar )
					this.RaisePropertyChangedEvent( StorageProps.Name_OwningCalendar );
			}
		}

		#endregion // SyncOwnerId

		#region SetLocal
		private void SetLocal(TimeZoneToken token, bool isStart, DateTime date)
		{
			CoreUtilities.ValidateNotNull(token, "token");

			if (this.IsTimeZoneNeutral)
				date = DateTime.SpecifyKind(date, DateTimeKind.Utc);
			else
				date = token.ConvertToUtc(date);

			if (isStart)
				this.Start = date;
			else
				this.End = date;
		}
		#endregion // SetLocal

		#endregion // Private Methods

		#endregion // Methods
	}

	#endregion // ActivityBase Class
}

#region Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved
/* ---------------------------------------------------------------------*
*                           Infragistics, Inc.                          *
*              Copyright (c) 2001-2012 All Rights reserved               *
*                                                                       *
*                                                                       *
* This file and its contents are protected by United States and         *
* International copyright laws.  Unauthorized reproduction and/or       *
* distribution of all or any portion of the code contained herein       *
* is strictly prohibited and will result in severe civil and criminal   *
* penalties.  Any violations of this copyright will be prosecuted       *
* to the fullest extent possible under law.                             *
*                                                                       *
* THE SOURCE CODE CONTAINED HEREIN AND IN RELATED FILES IS PROVIDED     *
* TO THE REGISTERED DEVELOPER FOR THE PURPOSES OF EDUCATION AND         *
* TROUBLESHOOTING. UNDER NO CIRCUMSTANCES MAY ANY PORTION OF THE SOURCE *
* CODE BE DISTRIBUTED, DISCLOSED OR OTHERWISE MADE AVAILABLE TO ANY     *
* THIRD PARTY WITHOUT THE EXPRESS WRITTEN CONSENT OF INFRAGISTICS, INC. *
*                                                                       *
* UNDER NO CIRCUMSTANCES MAY THE SOURCE CODE BE USED IN WHOLE OR IN     *
* PART, AS THE BASIS FOR CREATING A PRODUCT THAT PROVIDES THE SAME, OR  *
* SUBSTANTIALLY THE SAME, FUNCTIONALITY AS ANY INFRAGISTICS PRODUCT.    *
*                                                                       *
* THE REGISTERED DEVELOPER ACKNOWLEDGES THAT THIS SOURCE CODE           *
* CONTAINS VALUABLE AND PROPRIETARY TRADE SECRETS OF INFRAGISTICS,      *
* INC.  THE REGISTERED DEVELOPER AGREES TO EXPEND EVERY EFFORT TO       *
* INSURE ITS CONFIDENTIALITY.                                           *
*                                                                       *
* THE END USER LICENSE AGREEMENT (EULA) ACCOMPANYING THE PRODUCT        *
* PERMITS THE REGISTERED DEVELOPER TO REDISTRIBUTE THE PRODUCT IN       *
* EXECUTABLE FORM ONLY IN SUPPORT OF APPLICATIONS WRITTEN USING         *
* THE PRODUCT.  IT DOES NOT PROVIDE ANY RIGHTS REGARDING THE            *
* SOURCE CODE CONTAINED HEREIN.                                         *
*                                                                       *
* THIS COPYRIGHT NOTICE MAY NOT BE REMOVED FROM THIS FILE.              *
* --------------------------------------------------------------------- *
*/
#endregion Copyright (c) 2001-2012 Infragistics, Inc. All Rights Reserved